[{"title":"Hello World","path":"/2024/05/fa8f81d2fd3a.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"path":"/2024/05/6a8e9bdad2b3.html","content":"1. 基本知识 网站是指因特网上根据一定的规则，使用HTML等制作的用于展示特定内容相关的&#x3D;&#x3D;网页的集合&#x3D;&#x3D; 网页是网站的一页， 通常是HTML格式的文件， 它主要通过浏览器来阅读 网页是网站的基本元素 green, 通常由文字、图片、视频等组成。通常我们看到的网页是以.html或者.htm为后缀的文件，俗称为HTML文件 green 网页是由网页元素组成的，这些元素是利用html标签描述，然后通过浏览器解析来显示 **HTML**：超文本标记语言(Hyper Text Markup Language)，是用来 描述网页 的一种语言，由多种标签组成 不是编程语言，而是标记语言 所谓超文本： 超越了文本限制，可以添加音频、图片、视频等内容 超链接文本，可以从一个文件跳转到另一个文件，与世界各地主机的文件相连 浏览器内核：渲染引擎 green，负责读取网页内容，整理讯息，计算网页的显示方式并显示页面 **Web标准**：是由W3C组织和其他标准组织制定的&#x3D;&#x3D;一系列标准的集合&#x3D;&#x3D; Web标准的构成：结构(Structure)、表现(Presentation) 和 行为(Behavior) 标准 说明 结构 结构用于对网页元素进行整理和分类 表现 表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS 行为 行为指网页模型的定义及交互的编写 2. HTMLHTML语法规范所有的标签都必须包含在&lt; &gt;中标签都是成对出现的，称为双标签， 即开始标签 和 结束标签（&quot;/&quot;）1&lt;html&gt; &lt;/html&gt;也有单标签： 1&lt;br /&gt; 标签关系 包含关系（父子关系） 123&lt;head&gt;\t&lt;title&gt; &lt;/title&gt;&lt;head&gt; 并列关系 12&lt;head&gt; &lt;/head&gt;&lt;body&gt; &lt;/body&gt; 1. 基本结构标签每个网页都会有一个基本的结构标签，也称为`骨架标签` 标签名 定义 说明 &lt;html&gt; &lt;&#x2F;html&gt; HTML标签 根标签，页面中最大的标签 &lt;head&gt;&lt;&#x2F;head&gt; 文档的头部 在head标签中必须要设置title &lt;title&gt;&lt;&#x2F;title&gt; 文档的标题 让页面有一个属于自己的网页标题 &lt;body&gt;&lt;&#x2F;body&gt; 文档的主体 元素包含文档的所有内容 结构标签 VSCode工具生成骨架结构新增代码&lt;!DOCTYPE&gt;标签：文档类型声明，声明HTML版本必须写在文件第一行，声明标签—不属于HTML标签lang语言：定义当前文档显示的语言，eg：zh-CN、en、frcharset字符集：在标签内，可以通过标签的charset 属性来规定 HTML文档应该使用哪种字符编码。123456&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt; 2. HTML常用标签！！！根据标签的语义，在合适的地方给一个最为合理的标签，可以让页面结构更清晰！！！ 标题标签&lt;h1&gt; - &lt;h6&gt;HTML提供了6个等级的网页标题，从H1 — H6。 123456&lt;h1&gt;标题一共六级选，&lt;/h1&gt;&lt;h2&gt;文字加粗一行显。&lt;/h2&gt;&lt;h3&gt;由大到小依次减，&lt;/h3&gt;&lt;h4&gt;从重到轻随之变。&lt;/h4&gt;&lt;h5&gt;语法规范书写后，&lt;/h5&gt;&lt;h6&gt;具体效果刷新见。&lt;/h6&gt; 特点: 加了标题的文字会变的加粗，字号也会依次变大。 一个标题独占一行 段落标签和换行标签&lt;p&gt; &lt;/p&gt;：段落标签，将HTML文档分成若干段落 123456&lt;p&gt;环状RNA（Circular RNA，简称circRNA）为生物细胞中的一类RNA，由线状RNA5’端与3’端经共价结合（反向剪接）而形成，是一种广泛存在于真核细胞中的单链RNA。环状RNA在基因表达调控、细胞周期、信号转导等生物学过程中发挥重要作用。&lt;/p&gt;&lt;p&gt;最近的研究表明，环状RNA在许多疾病的发生和发展中也扮演着重要的角色，如癌症、心血管疾病、神经系统疾病等。环状rna可以作为一种可靠的疾病生物标志物。&lt;/p&gt; 特点: 文本在一个段落中会根据浏览器窗口的大小自动换行 段落和段落之间保有空隙 \\&lt;br /&gt;：换行标签，强制换行 12345&lt;p&gt;环状RNA（Circular RNA，简称circRNA）为生物细胞中的一类RNA，&lt;br&gt;由线状RNA5’端与3’端经共价结合（反向剪接）而形成，是一种广泛存在于真核细胞中的单链RNA。环状RNA在基因表达调控、细胞周期、信号转导等生物学过程中发挥重要作用。&lt;/p&gt; 特点: &lt;br&#x2F;&gt;是个单标签 &lt;br&#x2F;&gt;标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距 文本格式化标签 突出重要性，比普通文字更重要 语义 标签 加粗 **&lt;strong&gt;&lt;&#x2F;strong&gt;**或者&lt;b&gt;&lt;&#x2F;b&gt; 倾斜 **&lt;em&gt;&lt;&#x2F;em&gt;**或者 &lt;i&gt;&lt;&#x2F;i&gt; 删除线 **&lt;del&gt;&lt;&#x2F;del&gt;**或者&lt;s&gt;&lt;&#x2F;s&gt; 下划线 **&lt;ins&gt;&lt;&#x2F;ins&gt;**或者&lt;u&gt;&lt;&#x2F;u&gt; &lt;div&gt; 和 &lt;sapn&gt; 标签\\&lt;div&gt; 和 \\&lt;sapn&gt; 标签是没有语义的，只是一个盒子，用于装内容 12&lt;div&gt;这是内容1&lt;/div&gt;&lt;span&gt;这是内容2&lt;/span&gt; div – division，表示分割、分区 span 意为跨度、跨距 特点: &lt;div&gt;标签用来布局，但是现在一行只能放一个&lt;div&gt;。大盒子 &lt;span&gt;标签用来布局，一行上可以多个&lt;span&gt;。小盒子 图像标签和路径图像标签 &lt;img&gt;，单标签，用于定义HTML页面中的图像 1&lt;img src=&quot;data/106184969_p0.jpg&quot; alt=&quot;&quot;&gt; ``是``标签的必备属性，用于`指定图像文件的路径和文件名` 图片标签的其他属性： 属性 属性值 说明 src 图片路径 必须属性 alt 文本 替换文本。图像不能显示的文字 title 文本 提示文本。鼠标放到图像上，显示的文字 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 像素 设置图像的边框粗细 图像标签属性注意点: 图像标签可以拥有多个属性，必须写在标签名的后面 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开 属性采取键值对的格式，即key&#x3D;“value”的格式，属性&#x3D;“属性值” 路径： 相对路径：相对于HTML页面的位置 相对路径分类 符号 说明 同一级路径 图像文件位于HTML文件同一级 如&lt;img src&#x3D;”baidu.gif” &#x2F;&gt; 下一级路径 &#x2F; 图像文件位于HTML文件下一级 如&lt;img src&#x3D;”images&#x2F;baidu.gif” &#x2F;&gt;。 上一级路径 ..&#x2F; 图像文件位于HTML文件上一级 如&lt;img src&#x3D;”..&#x2F;baidu.gif” &#x2F;&gt; 绝对路径：指目录下的绝对位置，通常是从盘符开始的路径 超链接标签&lt;a&gt; 标签用于定义超链接，作用是从 一个页面链接到另一个页面 超链接的语法格式 1&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot; &gt; 文本或图像&lt;/a&gt; 属性 作用 href 指定链接的url地址，必须属性，当为标签应用href属性时，就具有了超链接功能 target 用于指定链接页面的打开方式，其中_self为默认值，当前窗口打开，_blank为在新窗口中打开 超链接的分类 外部链接：eg： &lt;a href&#x3D;”http://www.baidu.com“ target&#x3D;”_blank”&gt;1. 外部链接 – 百度 &lt;&#x2F;a&gt; 内部链接：网站内部页面之间的相互链接，直接链接内部页面名称即可，eg：&lt;a href&#x3D;”体育新闻.html” target&#x3D;”_blank”&gt;2. 内部链接 – 体育新闻 &lt;&#x2F;a&gt; 空链接：没有确定链接目标，eg：&lt;a href&#x3D;”#” target&#x3D;”_blank”&gt;3. 空链接 – 首页&lt;&#x2F;a&gt; 下载链接：如果href地址是一个文件或者压缩包（exe或者zip 等压缩包），会下载这个文件 网页链接元素：在网页中的各种网页元素，如文本，图像等 锚点链接：快速定位到页面中的某个位置 在链接文本的href属性中，设置属性值为 #名字的形式，eg：&lt;a href&#x3D;”#星期四”, target&#x3D;”_blank”&gt;6. 锚点链接 – 星期四&lt;&#x2F;a&gt; 找到目标位置标签，里面添加一个id属性，值为刚才的名字，eg：&lt;p id&#x3D;”星期四”&gt;明天星期四、、&lt;&#x2F;p&gt; 1234567891011121314&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot; &gt; 文本或图像&lt;/a&gt;&lt;h4&gt;1. 外部链接&lt;/h4&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;1. 外部链接 -- 百度&lt;/a&gt;&lt;h4&gt;2. 内部链接&lt;/h4&gt;&lt;a href=&quot;体育新闻.html&quot; target=&quot;_blank&quot;&gt;2. 内部链接 -- 体育新闻 &lt;/a&gt;&lt;h4&gt;3. 空连接 # &lt;/h4&gt;&lt;a href=&quot;#&quot; target=&quot;_blank&quot;&gt;3. 空链接 -- 首页&lt;/a&gt;&lt;h4&gt;4. 下载链接&lt;/h4&gt;&lt;a href=&quot;data/106184969_p0.zip&quot; target=&quot;_blank&quot;&gt;4. 下载链接 -- 文件&lt;/a&gt;&lt;h4&gt;5. 网页元素链接&lt;/h4&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;data/106184969_p0.jpg&quot; alt=&quot;图片显示错误&quot;, height=&quot;128&quot;, width=&quot;72&quot;&gt; &lt;/a&gt;&lt;h4&gt;6. 锚点链接&lt;/h4&gt;&lt;a href=&quot;#星期四&quot;, target=&quot;_blank&quot;&gt;6. 锚点链接 -- 星期四&lt;/a&gt;&lt;p id=&quot;星期四&quot;&gt;明天星期四&lt;/p&gt; 3. HTML中的注释和基本字符注释HTML中的注释以 &lt;!--开头，以--&gt;结尾 特殊字符在 HTML页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。 特殊字符 表格标签表格主要用于显示、展示数据 表格的基本语法 &lt;table&gt; &lt;&#x2F;table&gt; 用于定义表格 &lt;tr&gt;&lt;&#x2F;tr&gt;用于定义行，必须嵌套在&lt;table&gt; &lt;&#x2F;table&gt; 中 &lt;td&gt;&lt;&#x2F;td&gt;用于定义单元格，需嵌套在&lt;tr&gt;&lt;&#x2F;tr&gt;中 字母td指表格数据(table data)，即数据单元格的内容 表头单元格标签：&lt;th&gt;&lt;&#x2F;th&gt;，文本加粗居中显示 标签表示HTML表格的表头部分(table head 的缩写) 表格属性 通常使用CSS来设置表格属性，表格标签属性基本不常用 表格属性标签 这些属性要写到表格标签` 表格结构标签 表格可以分为表格头部和表格主体两大部分 表格头部：&lt;thead&gt;&lt;&#x2F;thead&gt;， 内部必须有&lt;tr&gt;标签 表格主体：&lt;tbody&gt;&lt;&#x2F;tbody&gt; 合并单元格 合并单元格方式 跨行合并，rowspan&#x3D;”合并单元格的个数” 跨列合并，colspan&#x3D;”合并单元格的个数” 目标单元格（写合并代码） 若是跨行合并，写在最上侧 若是跨列合并，写在最左侧 注意删除多余的单元格 列表标签 列表是用来布局的 根据使用情景不同，可分为 无序列表 12345&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt;&lt;/ul&gt; 无序列表的各个列表项之间没有顺序等级之分，是并列的 &lt;ul&gt;之间只能嵌套&lt;li&gt;，不允许嵌套其他标签或者文字 &lt;li&gt;之间相当于一个容器，可以嵌套任何元素 无序列表会带有自己的样式属性，但在使用时，通常使用CSS 有序列表 12345&lt;ol&gt; &lt;li&gt;A: 1000&lt;/li&gt; &lt;li&gt;B: 2000&lt;/li&gt; &lt;li&gt;C: 3000&lt;/li&gt;&lt;/ol&gt; &lt;ol&gt;之间只能嵌套&lt;li&gt;，不允许嵌套其他标签或者文字 &lt;li&gt;之间相当于一个容器，可以嵌套任何元素 无序列表会带有自己的样式属性，但在使用时，通常使用CSS 自定义列表 使用场景：常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号 123456&lt;dl&gt; &lt;dt&gt;数字&lt;/dt&gt; &lt;dd&gt;数字1&lt;/dd&gt; &lt;dd&gt;数字2&lt;/dd&gt; &lt;dd&gt;数字3&lt;/dd&gt;&lt;/dl&gt; &lt;dl&gt;标签之间只能包含&lt;dt&gt;和&lt;dd&gt; &lt;dt&gt;和&lt;dd&gt;个数没有限制，经常一个&lt;dt&gt;包含多个&lt;dd&gt; 表单标签表单的组成：表单域、表单控件（表单元素）、提示信息 表单域：一个包含表单元素的区域 &lt;form&gt;标签用于定义表单域，以实现用户信息的收集和传递 &lt;form&gt;会把它范围内的表单元素信息提交给服务器 常用属性 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址 method get&#x2F;post 用于设置表单数据的提交方式，其取值为get或者post name 名称 用于指定表单的名称，以区分一个页面中的多个表单域 表单控件（表单元素） Input输入表单元素 &lt;input&gt;标签用于收集用户信息，单标签 1&lt;input type=&quot; &quot; name=&quot;&quot; id=&quot;&quot;&gt; 单选&#x2F;复选框中的name属性要一致，才可以实现多选一&#x2F;多选 name和value是每个表单元素都有的属性值，主要给后台人员使用 name是表单元素的名字，要求单选按钮和复选框都要有相同的name值 单选按钮和复选框有checked属性，当页面打开时，默认选中这个按钮 maxlength是用户可以在表单元素输入时设置的最大字符数，一般较少使用 &lt;label&gt;标签 &lt;labe&gt;标签用于绑定一个表单元素， 当点击&lt;label&gt;标签内的文本时，浏览器就会自动将点(光标转到或者选择对应的表单元素上用来增加用户体验 12&lt;label for=&quot;sex1&quot;&gt;男：&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex1&quot; value=&quot;男&quot;&gt;&lt;label for=&quot;sex2&quot;&gt;女：&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex2&quot; value=&quot;女&quot;&gt; &lt;label&gt;标签的 for 属性应当与相关元素的id 属性相同 &lt;select&gt;表单元素 12345&lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;&quot;&gt;天津&lt;/option&gt; &lt;option value=&quot;&quot;&gt;山东&lt;/option&gt;&lt;/select&gt; &lt;select&gt;之间至少包含一对&lt;option&gt; 在&lt;option&gt;中定义selected &#x3D;“selected”时，当前项即为默认选中项 &lt;textarea&gt;文本域表单元素 1","categories":["前端学习"]},{"title":"linux创建用户并赋予sudo权限","path":"/2023/04/e6ba03a7e3b4.html","content":"https://www.sunzhongwei.com/ubuntu-2004-to-add-a-new-user-and-give-sudo-permissions","tags":["linux"],"categories":["杂谈","linux"]},{"title":"安装docker","path":"/2023/04/ebe25e5ec8d5.html","content":"1. 安装docker 卸载旧版本 123sudo apt-get remove docker \\ docker-engine \\ docker.io 使用 APT 安装 由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 12345678sudo apt-get updatesudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 12345curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg# 官方源# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 然后，我们需要向 sources.list 中添加 Docker 软件源 123456789echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 官方源# echo \\# &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。 安装Docker 1sudo apt-get install docker-ce docker-ce-cli containerd.io 启动Docker 123sudo systemctl enable dockersudo systemctl start dockerdocker -v\t# 检查docker版本 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： 1sudo groupadd docker 将当前用户加入 docker 组： 1sudo usermod -aG docker $USER 退出当前终端并重新登录，进行如下测试。 测试docker是否安装成功 1docker run --rm hello-world 输出以下内容： 1234567891011121314151617181920212223242526Unable to find image &#x27;hello-world:latest&#x27; locallylatest: Pulling from library/hello-worldb8dfde127a29: Pull completeDigest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 2. 迁移docker的默认安装（存储）路径Docker版本（23.0.3）修改安装(存储)目录：通过修改(新建) &#x2F;etc&#x2F;docker&#x2F;daemon.json ，指定 data-root 参数的值。 按如下操作： 1sudo vim /etc/docker/daemon.json 修改文件： 1234&#123; &quot;data-root&quot;: &quot;/store/software/docker&quot;, &quot;storage-driver&quot;: &quot;overlay2&quot;&#125; 将data-root改成你要迁移的路径 3. Docker – GPU镜像 安装docker–nvidia 1234567# 1、添加源distribution=$(. /etc/os-release;echo $ID$VERSION_ID)sudo curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -sudo curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list# 2、安装并重启sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkitsudo systemctl restart docker 拉取docker镜像 从nvidia&#x2F;cuda选择合适的镜像 1docker pull nvidia/cuda:11.6.1-cudnn8-devel-ubuntu20.04 创建容器 1docker run --name test -idt --gpus all nvidia/cuda:11.6.1-cudnn8-devel-ubuntu20.04 也可以通过写”device&#x3D;0”或者’”device&#x3D;0,1,2,3”‘来指定GPU 进入容器 1docker exec -it test /bin/bash ​ 使用nvidia-smi查看GPU信息 4. 安装Conda 进入容器 1docker exec -it test /bin/bash 进行基础的网络安装 1234apt-get updateapt install net-tools # ifconfig apt install iputils-ping # pingapt-get install -y wget # wget 找anaconda安装包并下载 conda官网 1wget https://repo.anaconda.com/archive/Anaconda3-5.3.0-Linux-x86_64.sh 安装解压程序 1apt-get install bzip2 找到anaconda.sh并进行解压安装 12chmod +x Anaconda3-5.3.0-Linux-x86_64.sh./Anaconda3-5.3.0-Linux-x86_64.sh 回车，一直yes ,vscode可以不进行安装 进行环境变量配置 12export PATH=$PATH:/root/anaconda3/bin\t# 默认安装在root/anaconda3source ~/.bashrc 使用conda -V查看版本信息 123conda -V输出：conda 4.5.11 conda activate 和 conda deactivate 报错：CommandNotFoundError: Your shell has not been properly configured to use ‘conda activate’. 输入以下命令：： 12source activatesource deactivate 5. 将本地环境部署到docker在本地环境中将需要打包的代码复制到docker中： 123# 获取docker中conda安装地址conda info --env# 输出： /root/anaconda3 将本地环境复制到docker中（使用ctrl + d 退出） 1docker cp your_env_path test://root/anaconda3/envs 再使用docker cp命令将代码复制到容器内 保存所作的修改！ 1docker commit -a &#x27;author&#x27; -m &#x27;instruction&#x27; test image_test 该命令各字段： test ：容器名字 image_test：保存的镜像的名字。 打包镜像 1docker save -o test_tar.tar image_test test_tar.tar: 压缩包名称 ， image_test： 镜像名称 加载已经打包好的镜像 1docker load -i test_tar.tar 参考： Docker–从入门到实践 两种方法迁移 Docker 的默认安装(存储)目录 Ubuntu18.04安装docker及nvidia docker","tags":["笔记","docker"],"categories":["杂谈"]},{"title":"Pyqt Designer","path":"/2023/03/de243851305f.html","content":"一些常用属性 minimumSize： 表示部件能被缩小到的最小尺寸，单位为像素，缩小到该尺寸后不能再进一步缩小了。如果部件在布局管理器中，且布局管理器也设置了最小尺寸，则部件本身的最小尺寸以部件的minimumSize为准，布局管理器设置的不起作用。 sizePolicy 部件的sizePolicy属性用于说明部件在布局管理中的缩放方式，当部件没有在布局管理器中时，该设置无效。 其中的常量值本身是由枚举类型PolicyFlag 的多个值组合而成，PolicyFlag 的取值及含义如下 contextMenuPolicy contextMenuPolicy为部件的快捷菜单策略，快捷菜单通过在部件上点击鼠标右键触发。","tags":["笔记， pyqt"],"categories":["杂谈"]},{"title":"nonebot搭建QQ机器人","path":"/2023/03/205f71508803.html","content":"框架介绍NoneBot2 是一个现代、跨平台、可扩展的 Python 聊天机器人框架，它基于 Python 的类型注解和异步特性，能够为你的需求实现提供便捷灵活的支持。 nonebot官方文档 搭建步骤 请确保你的 Python 版本 &gt;&#x3D; 3.8 1. 通过脚手架安装nb 安装 pipx 12python -m pip install --user pipxpython -m pipx ensurepath 安装脚手架 1pipx install nb-cli 如果提醒以下内容： 1234567 installed package nb-cli 1.0.5, installed using Python 3.10.9 These apps are now globally available - nb.exe⚠️ Note: &#x27;C:\\\\Users\\\\WMGray\\\\.local\\\\bin&#x27; is not on your PATH environment variable. These apps will not be globally accessible until your PATH is updated. Run `pipx ensurepath` to automatically add it, or manually modify your PATH in your shell&#x27;s config file (i.e. ~/.bashrc).done! ✨ 🌟 ✨ 请按照上面的警告输入命令：Run pipx ensurepath to automatically add it, or manually modify your PATH in your shell’s config file 然后根据接下来的输出进行 2.创建nb项目 输入nb来进行交互 选择创建一个NoneBot项目 选择模板 输入项目名称 选择适配器–FastAPI 选择驱动器–OneBotV11 3.项目配置 在.env更改配置项 123456HOST=127.0.0.1 # 配置 NoneBot2 监听的 IP/主机名PORT=8080 # 配置 NoneBot2 监听的端口SUPERUSERS=[&quot;123456789&quot;, &quot;987654321&quot;] # 配置 NoneBot 超级用户NICKNAME=[&quot;awesome&quot;, &quot;bot&quot;] # 配置机器人的昵称COMMAND_START=[&quot;/&quot;, &quot;&quot;] # 配置命令起始字符COMMAND_SEP=[&quot;.&quot;] # 配置命令分割字符 其他参数见NoneBot配置 4.下载gocq go-cqhttp选择合适的版本 双击exe生成运行脚本 选择通信方式（本文选择的反向WebSocket） 若要支持任意格式语音发送，可安装ffmpeg 从 这里 下载 并解压, 并为 bin 这个文件夹添加环境变量 然后在 cmd 输入 (不能使用 powershell） 12setx /M PATH &quot;C:\\Program Files\\ffmpeg\\bin;%PATH%&quot;# 自行将这个指令中的 C:\\Program Files 替换成你的解压目录 生成config.yaml后修改以下信息 1234uin: 1233456 # QQ账号password: &#x27;&#x27; # 密码为空时使用扫码登录.... universal: ws://127.0.0.1:端口号/onebot/v11/ws/\t#端口号同bot项目下的.env端口 5. 启动bot1nb run\t# 在项目界面 同时，运行go-cqhttp.bat","tags":["笔记","NoneBot","QQ机器人"],"categories":["杂谈"]},{"title":"Hexo搭建笔记","path":"/2023/03/83f5e002c6f9.html","content":"搭建hexo 下载并安装node.js 官网下载：https://nodejs.org/en/ 验证：node -v Node.js v20.13.1 命令行安装cnpm 命令：npm install -g cnpm –registry&#x3D;&#x3D;https://registry.npm.taobao.org 验证：cnpm -v 命令行安装hexo 命令npm install -g hexo-cli 验证：hexo -v hexo-cli: 4.3.2 建站 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 配置主题 主题的配置应放在 themes 文件夹下 上传前删除 themes&#x2F;.gitkeep 在_config.yml 修改theme为你的主题名称 Github + Hexo 新建一个仓库，名为用户名.github.io 本地hexo仓库关联远程GitHub仓库 本地仓库一些必要的修改配置 可以自动化给文章分类 pre-commit文件 安装 hexo-deployer-git 1npm install hexo-deployer-git --save 修改 _config.yml 配置 url: https://all-smile.github.io/blog root: &#x2F;blog&#x2F; … deploy: ​\ttype: ‘git’ ​\trepo: &#103;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#46;&#99;&#x6f;&#109;:all-smile&#x2F;blog.git #这个是你的仓库的ssh ​\tbranch: gh-pages\t# 要部署的分支，本教程博客源码在master分支，部署在gh-pages分支 提交到远程仓库 创建 gh-pages 分支 hexo结合GitHub创建个人网站指定的分支名，hexo 内默认设置的分支也是叫这个名字 12git checkout -b gh-pagesgit push -u origin gh-pages 远程仓库开启 github pages 指定部署分支：gh-pages 右上Setting –&gt; Pages –&gt; Branch –&gt;选择gh-pages –&gt;save 手动部署 命令： 123hexo cleanhexo ghexo deploy hexo模板引擎生成静态文件，并推送到gh-pages分支下（替换原先分支下的所有文件） 需要注意的是：hexo deploy 命令并不会帮助我们同步本地的修改到远程仓库，所以当在本地写完博文之后，要做两件事：一是发布站点，二是同步远程仓库，这样做比较麻烦，下面会讲解如何配置持续集成 自动部署–Github Actions1. 设置 SSH 私钥 deploy_key创建 SSH 部署密钥(使用git bash) 1ssh-keygen -t rsa -b 4096 -C &quot;$(git config user.email)&quot; -f gh-pages -N &quot;&quot; 您将获得 2 个文件： gh-pages.pub是公钥 Settings –&gt; Deploy Keys –&gt; Add deploy key name写为public key of ACTIONS_DEPLOY_KEY Key为.pub中的内容 勾选Allow write acess gh-pages是私钥 Settings –&gt; Secrets and variavles –&gt; Actions –&gt; New repository secret name为ACTIONS_DEPLOY_KEY value为gh-pages中的内容 不要上传私钥！！！ 2. 新建 .github&#x2F;workflows&#x2F;pages.yml 文件文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273name: Pages# 触发器、分支on: push: branches: - master # default branchjobs: # 子任务 pages: runs-on: ubuntu-latest # 定运行所需要的虚拟机环境 permissions: contents: write steps: - uses: actions/checkout@v2 # with: # submodules: true # fetch-depth: 0 # 每个name表示一个步骤:step - name: Use Node.js 16.x uses: actions/setup-node@v2 with: node-version: &#x27;16.14.1&#x27; # 自己正在使用的node版本即可 # - run: node -v # 查看node版本号 # 缓存依赖项: https://docs.github.com/cn/actions/using-workflows/caching-dependencies-to-speed-up-workflows - name: Cache NPM dependencies uses: actions/cache@v2 with: # npm cache files are stored in `~/.npm` on Linux/macOS path: ~/.npm # path: node_modules key: $&#123;&#123; runner.OS &#125;&#125;-npm-cache restore-keys: | $&#123;&#123; runner.OS &#125;&#125;-npm-cache # 查看路径 : /home/runner/work/blog/blog # - name: Look Path # run: pwd # 查看文件 - name: Look Dir List run: tree -L 3 -a # 第一次或者依赖发生变化的时候执行 Install Dependencies，其它构建的时候不需要这一步 - name: Install Dependencies run: npm install - name: Look Dir List run: tree -L 3 -a # - name: clean theme cache # run: git rm -f --cached themes/tenacity # run: git submodule deinit themes/tenacity &amp;&amp; git rm themes/tenacity # 安装主题 - name: Install Theme run: git submodule add https://github.com/all-smile/tenacity.git themes/tenacity - name: Clean run: npm run clean - name: Build run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; user_name: xxxx\t# 需要修改 user_email: xx@xx.com\t#需要修改 # 获取提交文章源码时的commit message，作为发布gh-pages分支的信息 commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; full_commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; # GITHUB_TOKEN不是个人访问令牌，GitHub Actions 运行器会自动创建一个GITHUB_TOKEN密钥以在您的工作流程中进行身份验证。因此，您无需任何配置即可立即开始部​​署 publish_dir: ./public allow_empty_commit: true # 允许空提交 # Use the output from the `deploy` step(use for test action) - name: Get the output run: | echo &quot;$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;&quot; 3. 修改 _config.yml 文件中的Deploy配置12345678# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: &#x27;git&#x27; repo: ....... branch: gh-pages # 默认提交信息： Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125; message: $&#123;&#123; github.event.head_commit.message &#125;&#125; # 直接将提交消息传输到 GitHub Pages 存储库 上传blog时记得切换回master分支 参考 Hexo+GitHub搭建个人博客，实现云端编辑、一键发文 hexo 2021最全hexo搭建博客+matery美化+使用（保姆级教程）","tags":["笔记","hexo"],"categories":["杂谈"]},{"title":"Hexo自动分类","path":"/2023/03/fe7cc4ff31af.html","content":"目的给每一个笔记自动添加分类（习惯了使用文件夹分类） 自动分类 使用的是hexo-auto-category这个基于文件夹自动分类的插件，安装： 1npm install hexo-auto-category --save 在_config.yml文件中添加配置： 1234567# Generate categories from directory-tree# Dependencies: https://github.com/xu-song/hexo-auto-category# depth: the max_depth of directory-tree you want to generate, should &gt; 0auto_category:\tenable: true\tdepth:3 除此之外最好修改一下 _config.yml 中的两处默认配置： 12345# 修改 permalink 让你的文章链接更加友好，并且有益于 SEOpermalink: :year/:month/:hash.html# 规定你的新文章在 _post 目录下是以 cateory new_post_name: :category/:title 在每个文章的开头添加以下： Obsidian可以创建模板 123456---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;categories: tags:--- 利用Git钩子函数触发更新 查看当前仓库中 Git 钩子脚本的路径 1git config core.hooksPath 如果是~/.githooks要改成~/.git/hooks 1git config core.hooksPath .git/hooks 在.git/hooks目录下新建一个pre-commit文件 可以先在该文件中写入echo hello world!，然后在git bash执行sh pre-commit或者./pre-commit测试钩子能不能正常执行 没问题后，将如下命令写到文件里: 12#!/bin/shhexo generate &amp;&amp; git add . 之所以后面追加git add .，是因为generate后，所有文章的Front-matter信息会更新，所以要将所有修改重新添加进来 注意第一行一定要加上#!/bin/sh，这个不是注释！ 可是使用git commit 试试是否成功 这样你新建一篇博客的工作流就简化为： 创建分类目录，写文章； 填写 title、date、tag 等元信息; 添加 git 工作区变更，并提交并推送代码到 github。 参考 Obsidian+Git完美维护Hexo博客 Hexo + Obsidian + Git 完美的博客部署与编辑方案","tags":["笔记","hexo"],"categories":["杂谈"]},{"title":"Hexo搭建笔记","path":"/notes/杂谈/Hexo搭建笔记.html","content":"搭建hexo 下载并安装node.js 官网下载：https://nodejs.org/en/ 验证：node -v 命令行安装cnpm 命令：npm install -g cnpm –registry&#x3D;&#x3D;https://registry.npm.taobao.org 验证：cnpm -v 命令行安装hexo 命令npm install -g hexo-cli 验证：hexo -v 建站 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 配置主题 主题的配置应放在themes文件夹下 上传前删除themes&#x2F;.gitkeep 在_config.yml 修改theme为你的主题名称 Github + Hexo 新建一个仓库，名为用户名.github.io 本地hexo仓库关联远程GitHub仓库 本地仓库一些必要的修改配置 可以自动化给文章分类 pre-commit文件 安装 hexo-deployer-git 1npm install hexo-deployer-git --save 修改_config.yml配置 url: https://all-smile.github.io/blog root: &#x2F;blog&#x2F; … deploy: ​\ttype: ‘git’ ​\trepo: &#103;&#x69;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#x62;&#46;&#x63;&#111;&#109;:all-smile&#x2F;blog.git #这个是你的仓库的ssh ​\tbranch: gh-pages\t# 要部署的分支，本教程博客源码在master分支，部署在gh-pages分支 提交到远程仓库 创建 gh-pages 分支 hexo结合GitHub创建个人网站指定的分支名，hexo 内默认设置的分支也是叫这个名字 12git checkout -b gh-pagesgit push -u origin gh-pages 远程仓库开启 github pages 指定部署分支：gh-pages 右上Setting –&gt; Pages –&gt; Branch –&gt;选择gh-pages –&gt;save 手动部署 命令： 123hexo cleanhexo ghexo deploy hexo模板引擎生成静态文件，并推送到gh-pages分支下（替换原先分支下的所有文件） 需要注意的是：hexo deploy 命令并不会帮助我们同步本地的修改到远程仓库，所以当在本地写完博文之后，要做两件事：一是发布站点，二是同步远程仓库，这样做比较麻烦，下面会讲解如何配置持续集成 自动部署–Github Actions1. 设置 SSH 私钥 deploy_key创建 SSH 部署密钥(使用git bash) 1ssh-keygen -t rsa -b 4096 -C &quot;$(git config user.email)&quot; -f gh-pages -N &quot;&quot; 您将获得 2 个文件： gh-pages.pub是公钥 Settings –&gt; Deploy Keys –&gt; Add deploy key name写为public key of ACTIONS_DEPLOY_KEY Key为.pub中的内容 勾选Allow write acess gh-pages是私钥 Settings –&gt; Secrets and variavles –&gt; Actions –&gt; New repository secret name为ACTIONS_DEPLOY_KEY value为gh-pages中的内容 不要上传私钥！！！ 2. 新建 .github&#x2F;workflows&#x2F;pages.yml 文件文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273name: Pages# 触发器、分支on: push: branches: - master # default branchjobs: # 子任务 pages: runs-on: ubuntu-latest # 定运行所需要的虚拟机环境 permissions: contents: write steps: - uses: actions/checkout@v2 # with: # submodules: true # fetch-depth: 0 # 每个name表示一个步骤:step - name: Use Node.js 16.x uses: actions/setup-node@v2 with: node-version: &#x27;16.14.1&#x27; # 自己正在使用的node版本即可 # - run: node -v # 查看node版本号 # 缓存依赖项: https://docs.github.com/cn/actions/using-workflows/caching-dependencies-to-speed-up-workflows - name: Cache NPM dependencies uses: actions/cache@v2 with: # npm cache files are stored in `~/.npm` on Linux/macOS path: ~/.npm # path: node_modules key: $&#123;&#123; runner.OS &#125;&#125;-npm-cache restore-keys: | $&#123;&#123; runner.OS &#125;&#125;-npm-cache # 查看路径 : /home/runner/work/blog/blog # - name: Look Path # run: pwd # 查看文件 - name: Look Dir List run: tree -L 3 -a # 第一次或者依赖发生变化的时候执行 Install Dependencies，其它构建的时候不需要这一步 - name: Install Dependencies run: npm install - name: Look Dir List run: tree -L 3 -a # - name: clean theme cache # run: git rm -f --cached themes/tenacity # run: git submodule deinit themes/tenacity &amp;&amp; git rm themes/tenacity # 安装主题 - name: Install Theme run: git submodule add https://github.com/all-smile/tenacity.git themes/tenacity - name: Clean run: npm run clean - name: Build run: npm run build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: $&#123;&#123; secrets.ACTIONS_DEPLOY_KEY &#125;&#125; user_name: xxxx\t# 需要修改 user_email: xx@xx.com\t#需要修改 # 获取提交文章源码时的commit message，作为发布gh-pages分支的信息 commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; full_commit_message: $&#123;&#123; github.event.head_commit.message &#125;&#125; github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; # GITHUB_TOKEN不是个人访问令牌，GitHub Actions 运行器会自动创建一个GITHUB_TOKEN密钥以在您的工作流程中进行身份验证。因此，您无需任何配置即可立即开始部​​署 publish_dir: ./public allow_empty_commit: true # 允许空提交 # Use the output from the `deploy` step(use for test action) - name: Get the output run: | echo &quot;$&#123;&#123; steps.deploy.outputs.notify &#125;&#125;&quot; 3. 修改 _config.yml 文件中的Deploy配置12345678# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: &#x27;git&#x27; repo: ....... branch: gh-pages # 默认提交信息： Site updated: &#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125; message: $&#123;&#123; github.event.head_commit.message &#125;&#125; # 直接将提交消息传输到 GitHub Pages 存储库 上传blog时记得切换回master分支 参考 Hexo+GitHub搭建个人博客，实现云端编辑、一键发文 hexo 2021最全hexo搭建博客+matery美化+使用（保姆级教程）","tags":[null,null],"categories":[null]},{"title":"Prompt-Guided Injection of Conformation to Pre-trained Protein Model","path":"/notes/微调/Prompt-Guided Injection of Conformation to Pre-trained Protein Model.html","content":"url #微调 #生物 #提示学习 Summary​ 针对目前蛋白质预训练模型生成的embedding固定的问题，提出了一种解决思路：在预训练中引入prompt learning，可以针对不同的下游任务选择不同的prompt，将相关知识注入到模型中以便产生多变的embedding Background​ 给定一个氨基酸序列，除非蛋白质变性，否则一级结构和二级结构（无序区域除外）将被确定。由于大分子不是刚性的，蛋白质结构可以响应各种生物过程而发生可逆的变化。同一蛋白质的不同结构称为不同构象，它们之间的转变称为构象变化，各种3D构象是从其结构预测蛋白质功能的主要障碍。 native conformation（NC）指蛋白质自然折叠成的3D结构， interaction conformation（IC）指蛋白质在实现其生物功能时折叠成与其他蛋白质相互作用的对应结构。 ​\t蛋白质预训练模型用一个固定的embedding表示一个蛋白质，无法胜任多样化的任务 Significance​\t解决了固定的蛋白质嵌入难以获得其他知识的问题 Method​\t使用预训练模型训练相关提示，并将prompt与蛋白质embedding拼接，再经过transformer获得增强后的蛋白质表示 Results PTPM可以从不同的prompt中获取不同的知识，进而生成具有不同知识的嵌入，在需要特定知识的蛋白质相关任务中表现不错 prompt对于模型来说不一定都是有益的，它可能对某些任务是有害的。需要针对不同的任务选择合适的prompt prompt可以作为“知识探针”（可以先在具体任务上注入某些prompt，然后根据不同prompt的表现来确定该任务需要哪一种知识） Limitations​\t怎么选择合适的prompt对于模型来说可能是一个问题 Questions 为了促进正交性和泛化性，提示之间的信息流也被禁止 正交性指的是模型的不同部分之间相互独立，这样可以避免在训练过程中出现冗余信息，不会假设输入中的特征之间有任何相互作用，避免模型偏向于某些特定的输入形式，从而提高模型的泛化能力。 泛化性指的是模型能够很好地推广到未知的数据上，这样能够更好地应对实际应用中的变化。 阻止提示之间的信息流也有助于防止过拟合，从而提高模型的鲁棒性。 详细介绍 背景： 蛋白质预训练模型用一个固定的embedding表示一个蛋白质，因此无法胜任多样化的任务 为了使PTPMs产生信息表示，学习可解释、可插入和可扩展的蛋白质提示，将相关知识注入PTPMs 使用掩码语言建模任务的PTPMs优化被解释为学习序列提示（Seq prompt），使PTPM能够捕获氨基酸之间的顺序依赖性。 为了将构象知识结合到PTPM中，我们提出了一种相互作用**构象**提示（ interaction-conformation prompt， IC prompt），它通过与蛋白质-蛋白质相互作用任务的反向传播来学习 提出构象感知预训练蛋白质模型，在多任务设置中学习序列和相互作用构象提示 贡献： 我们建议学习可插入、可解释和可扩展的提示，以将与任务相关的知识注入预训练的蛋白质模型。 设计了 ConfProtein 模型，该模型将顺序和构象知识注入到多任务设置中的预训练蛋白质模型中 创建了一个新的数据集，其中包含用于接触预测的相互作用构象信息。 对蛋白质功能和结构预测任务的综合评估表明，适当的提示可以显着提高预训练模型的性能。 本文模型： 将任务相关知识(如构象信息)注入到PTPMs中，以生成更有信息的蛋白质表示 使用prompts避免微调PTLMs，从而提高性能。 ConfProtein 有两个可学习的提示，分别针对蛋白质本身的特性和蛋白质对中的交互构象。 人类仍然不能完全理解生命的语言，即氨基酸序列。因此，基于氨基酸词汇表设计提示语是不可行的。而现有的连续提示是面向任务的，泛化性低。 蛋白质本身的属性可以通过氨基酸序列来挖掘，我们利用掩码语言建模（MLM）任务（Devlin et al, 2019）来学习这个提示，称为序列提示（Seq prompt）。 对于存在于相互作用对中的构象，利用蛋白质相互作用预测(PPI)任务学习**相互作用构象提示(IC提示)**。 Protein Prompt Learning 参考 传统预训练模型embedding operator:\t$$E(·) &#x3D; E_{tok}(·) + E_{seg}(·) + E_{pos}(·)， token, segment, position$$ token embedding 层是要将各个词转换成固定维度的向量。 segment embeddings 区分一个句子对中的两个句子。Segment Embeddings 层只有两种向量表示。前一个向量是把0赋给第一个句子中的各个token, 后一个向量是把1赋给第二个句子中的各个token。 position embeddings能够让Bert理解同一个词应该有不同的向量表示 对于Prompt Learning，模型输入有两部分：原始输入序列$S_{in}$ + 提示$S_{pt}$ 假设prompt对输入序列$S_{in}$施加的影响不受prompt位置的干扰 $S_{in}$ Embedding：\t$\\mathbf X_{in} &#x3D; E(S_{in}) $ $S_{pt}$ Embedding： $\\mathbf X_{pt} &#x3D; E_{tok}(S_{pt}) &#x3D; {E_{tok}(s^1_{pt}), . . . , E_{tok}(s^m_{pt})}$ 完整输入： $\\mathbf X_{prompt} &#x3D; \\mathbf X_{in} || \\mathbf X_{pt}$ ​ $||$表示两个向量之间的连接操作 通过transformer中的自注意力机制，整个序列中的每一个token都可以关注到全局信息。 prompt应该为原始输入序列的表示提供任务相关信息，因此只允许从提示到原始输入的单向信息流 为了促进正交性和泛化性，提示之间的信息流也被禁止。 注意力掩码矩阵M： m – prompt长度 n – seq长度 输出计算： 损失函数： $\\mathcal L_C$：knowledge conservation objective $\\mathcal L_C &#x3D; \\mathcal L{pr}(h)$ 使预训练的模型保存从预训练任务中学习到的知识 $\\mathcal L_{pr}$为前一任务的损失函数，eg：预训练期间的 MLM 损失函数 $\\mathcal L_P$： knowledge injection objective $\\mathcal L_I &#x3D; \\sum_{\\tau \\in T} α_τ L_τ (h)$ 指导预训练模型获取新知识 $\\mathcal L_\\tau$是相关任务集合$T$中某一任务$\\tau$的损失 我们假设一种特定类型的知识，如蛋白质构象，可以从多个相关任务中学习，如蛋白质-蛋白质相互作用和结合亲和性预测。 $\\mathcal L$： $\\mathcal L &#x3D; \\mathcal L_C + \\lambda \\mathcal L_P $ $\\lambda$是一个超参数，用于平衡新的损失和旧的损失。（balancing the previous and new losses.） ​ ConfProtein 使用预训练MLM任务，在给定的环境中恢复替换的氨基酸，以优化PTPM和序列提示（seq prompt）$x_{Seq}$ 通过新任务–预测第p个蛋白和第q个蛋白能否发生相互作用，来学习相互作用构象提示（IC prompt）$x_{IC}$ 实验： 数据集 ​ 预训练数据集： STRING(Szklarczyk et al., 2019)，包含用于模型预训练的蛋白质-蛋白质相互作用对。 STRING数据集中的一些相互作用不会形成稳定的构象。为了去除不稳定构象，我们从STRING中选择了物理上唯一的相互作用子集。该子集包含来自14,094个物种的6500万个蛋白质序列和27亿个蛋白质-蛋白质相互作用对。可以定义一个PPI网络，其中一个节点代表一个蛋白质，一条边代表两个相互作用的蛋白质。蛋白质对之间的边缘表明有证据表明它们结合或形成了物理复合体(physical complex)。 下游数据集： SHS27k、SHS148k和STRING Homo Sapiens Chen等人(2019))基于随机选择的Homo sapiens PPI data创建了SHS27k和SHS148k数据集 STRING-HomoSapiens：使用所有的数据 使用BFS和DFS分别用于划分SHS27k、SHS148k和STRING Homo Sapiens的训练和评估数据集。 利用PPI预测任务来评估IC提示是否可以向PTPM注入构象知识。 在预训练期间，模型会预测两种蛋白质是否可以相互作用；在下游任务上，除了预测相互作用外，模型还会预测两种蛋白质的相互作用类型 其他数据集—用于其他任务 TAPE是一项旨在评估蛋白质模型普适性的基准。该基准涉及三个主要方面：结构预测、远系同源物检测和蛋白质工程。 数据集的构建 为了将相互作用构象知识注入到 ConfProtein 中，我们构建了一个 PPI 数据集——一个大规模的物理交互网络。我们使用仅具有物理模式的最新 STRING 数据库，这意味着蛋白质对之间的边表明它们结合或形成物理复合体的证据。该数据库共包含来自 14,094 个物种的 6500 万个蛋白质序列和 27 亿个蛋白质-蛋白质相互作用对。 请注意，来自不同物种的蛋白质之间没有边界。 PPI网络存在分布不均匀的问题，最大的网络包含6万个蛋白质和3.5 × 107条边。这样的数据分布可能导致模型过度关注单一物种的蛋白质。选择具有相当大小的物种网络来预处理数据集。 接触图数据 ICProtein 2：接触图的数据集，包含1106个蛋白质复合物，共2212个接触图 ICProtein 2的构建： 从Computed structures of core eukaryotic protein complexes中获取所有蛋白质复合物的结构数据 使用obabel转换文件格式，计算残差距离，获得基于interaction conformation的接触图 上一步得到的接触图为两个相互作用的蛋白质的接触图组成，将之分离 预训练 实验环境： Pytorch (Paszke et al., 2019) Fairseq (Ott et al.,2019) 参数设置： ConfProtein有650M参数，33层，20个注意头。 embedding size &#x3D; 1280 batch size &#x3D; 20 learning rate &#x3D; 0.00001 无权值衰减 固定学习率 氨基酸最大长度为2048 baseline 非预训练模型 DPPI (Hashemifar et al., 2018)、 DNN-PPI (H et al.,2018)、 PIPR (Chen et al., 2019)、GNN-PPI (Chen et al., 2019) 前三个基线使用不同的深度学习架构（CNN、RCNN和LSTM）将氨基酸嵌入转换为蛋白质嵌入，并使用线性分类器预测两种蛋白质是否具有相互作用关系。 GNN-PPI利用图形神经网络来关注整个交互图形，并实现SOTA性能。 ProtBert(Elnaggar et al., 2021)、OntoProtein和ESM-1b（Rao等人，2021a）是三种预先训练的模型。 为了公平比较，我们只使用预训练模型来生成氨基酸嵌入，并将这些嵌入输入GNN-PPI ConfProtein-w&#x2F;o-IC是我们ConfProtein的变体，仅包括Seq提示，不包括IC提示。 由于ConfProtein的结构与ESM-1b相同，我们通过比较ConfProtein-w&#x2F;o-IC和ESM-1b来检查Seq提示是否可以保存序列氨基酸信息，以及IC提示是否可以通过比较ConfProtein和ConfProtein-w&#x2F;o-IC来注入构象知识。 下游任务定义 蛋白质-蛋白质相互作用预测 抗体-抗原结合亲和力预测 联系预测 Contact Prediction 二级结构预测 荧光 Stability ​ 结果： 使用 Seq Prompt不会损害 PTPM 在序列相关任务上的表现，带有Seq提示的PTPMs只能获得氨基酸序列和相关二级结构的知识， 结合 IC Prompt可显着提高 PTPM 在交互构象知识重要的任务上的表现，可以有效地获得三维结构的知识。 具有恰当的学习提示的PTPMs优于最新的(SOTA)模型，而不恰当的提示将降低其性能。 IC Prompt 可以改善蛋白质预训练模型的PPI预测性能 在最大的STRING Homo Sapiens数据集上，GNN-PPI的性能超过所有PTPM。这是由于内存限制，我们计算氨基酸嵌入序列的平均值作为蛋白质表示。它的性能不如GNN-PPI中的卷积网络。 OntoProtein将知识图中的信息整合到蛋白质表示中,但其性能并不怎么好—&gt;表明并非知识图中的所有信息都对PPI任务有贡献作用，无用的信息对于模型来说可能是有害的。 IC Prompt可以增强具有相互作用构象知识的蛋白质表示 消融实验 数据集：SHS27k + SAbDab 对比： Seq Prompt IC Prompt 预测任务：PPI预测和抗体-抗原结合亲和力预测 Seq提示在SAbDab数据集中有更大的影响力，在抗体-抗原结合亲和力的预测中，氨基酸的性质是一个关键因素，可以通过Seq prompt得到 IC Prompt在STRING-HomoSapiens数据集中影响力更大，PPI是由蛋白质构象决定的，ConfProtein可以通过IC prompt获得构象知识 解释IC Prompt a.可视化了有和没有IC提示的TAF4蛋白氨基酸的嵌入 b.一个氨基酸的两次嵌入之间的距离 c.红色标记距离大于100的嵌入对 标记的嵌入都是蛋白质表面的氨基酸，这与与PPI相关的氨基酸几乎都位于蛋白质表面，而不是核心的事实相一致 Prompt对下游任务可能有不利影响 相同的提示在不同的数据集中对相同的任务产生截然相反的效果，说明使用不适当的知识会产生负面影响。 ConfProtein在长蛋白质中更有效。这是因为较长的蛋白质序列在不同构象的接触图之间差异较大，需要更多的3D信息才能准确预测接触图。 Prompt可以与下游任务无关 利用二级结构预测任务来探索提示如何在不需要它们的任务上执行。 数据集：CB513 MSA Transformer可以利用MSA获得NC IC提示可以提供具有IC的蛋白质表示 提示可以是未知下游任务的知识探测\tPrompts can be knowledge probe for unknown downstream tasks. 由于每个提示在学习后都可以被赋予特定的语义，我们利用提示作为知识探针来确定每个任务所需的信息 两个蛋白质工程任务:荧光景观预测和稳定性景观预测 绿色荧光蛋白在光照下表现出明亮的绿色荧光。 荧光景观预测任务的目的是将蛋白质映射到对数荧光强度。 蛋白质由氨基酸构成，氨基酸的化学性质决定了蛋白质的整体功能和3D结构 预训练语言模型（PTLMs）在语言理解、翻译和对话系统中表现优异，是一种处理序列数据的流行方法。 受到启发，开发了先训练的蛋白质模型（PTPMs），例如：TAPE Transformer、ProtBERT、ESM-1b，来预测蛋白质结构和功能。 在蛋白质二级结构预测、亲和性预测和接触预测等下游任务上表现不错。 存在的问题：蛋白质构象是非常敏感和动态的，受外界因素及其特定功能的显著影响。现有的PTPMs使用固定的embedding来表示一种蛋白质是不合适的。 给定一个氨基酸序列，除非蛋白质变性，否则一级结构和二级结构（无序区域除外）将被确定。各种3D构象是从其结构预测蛋白质功能的主要障碍。 同一蛋白质的不同结构称为不同构象，它们之间的转变称为构象变化。 构象（conformation）：在有机化合物分子中，由C—C单键旋转而产生的原子或基团在空间排列的无数特定的形象称为构象。指一个分子中，不改变共价键结构，仅单键周围的原子放置所产生的空间排布。不同的构象之间可以相互转变,在各种构象形式中,势能最低、最稳定的构象是优势构象。一种构象改变为另一种构象时，不要求共价键的断裂和重新形成。构象改变不会改变分子的光学活性。 由氨基酸组成的蛋白质是动态的，可以观察到各种三维结构，称为构象 native conformation（NC）指蛋白质自然折叠成的3D结构， interaction conformation（IC）指蛋白质在实现其生物功能时折叠成与其他蛋白质相互作用的对应结构。 contact map：蛋白质接触图使用二元二维矩阵表示三维蛋白质结构的所有可能的氨基酸残基对之间的距离。参考 Prompts：是由人类设计的离散单词序列或通过反向传播学习的连续向量。 RSCB术语 参考 不对称单元（Asymmetric Unit）是晶体学中的一个概念。定义是：在空间群的对称操作作用下，可以产生出晶胞中全部源自的最少数目的原子或原子团，就叫做不对称单元或不对称单位，也就是晶体学独立单元。也就是说不对称单元可以通过对称操作形成晶胞。我们从PDB数据库上下载的原子坐标文件就是其实是一个不对称单元中的原子数据。 生物学集合体（Biological Assembly）有时候又被称为生物学单元（Biological Unit），从生物学功能上定义的单元。比如有功能的血红蛋是四聚体，这四聚体就称为一个生物学单元。 不对称单元可能包含一个biological assembly；也可能只是biological assembly的一部分；也可能包含多个biological assembly。 Prompt learning： 参考 Prompt 是一种为了更好的使用预训练语言模型的知识，采用在输入段添加额外的文本的技术。 目的：更好挖掘预训练语言模型的能力 手段：在输入端添加文本，即重新定义任务（task reformulation） prompt construction【Template】 首先我们需要构建一个模版Template，模版的作用是将输入和输出进行重新构造，变成一个新的带有mask slots的文本，具体如下： 定义一个模版，包含了2处代填入的slots：[x] 和 [z] 将[x] 用输入文本代入 answer construction【Verbalizer】 对于我们构造的prompt，我们需要知道我们的预测词和我们的label 之间的关系，并且我们也不可能运行z是任意词，这边我们就需要一个映射函数（mapping function）将输出的词与label进行映射。例如我们的这个例子，输出的label 有两个，一个是:smile: ，一个是:worried: ，我们可以限定，如果预测词是fantastic 则对应:smile:,如果是 boring 则对应:worried: answer prediction【Prediction】 到了这边我们就只需要选择合适的预训练语言模型，然后进行mask slots [z] 的预测。例如下图，得到了结果 fantastic, 我们需要将其代入[z] 中。 answer-label mapping【Mapping】 对于得到的 answer，我们需要使用 Verbalizer 将其映射回原本的label。 Knowledge Graph（知识图谱）：知识图谱（Knowledge Graph）主要是用于描述现实世界中的实体（区别于概念，是指客观世界中的具体实物，如张三，李四等）、概念（人们在认识世界过程中形成的对客观事物的概念化表示，如人、动物等）及事件间的客观关系。知识图谱的构建过程即从非结构化数据（图像等）或半结构化数据（网页等）中抽取信息，构建结构化数据（三元组，实体-属性-关系）的过程。参考 ​","tags":[null,null,null],"categories":[null]},{"title":"Hexo自动分类","path":"/notes/杂谈/Hexo自动分类.html","content":"目的给每一个笔记自动添加分类（习惯了使用文件夹分类） 自动分类 使用的是hexo-auto-category这个基于文件夹自动分类的插件，安装： 1npm install hexo-auto-category --save 在_config.yml文件中添加配置： 1234567# Generate categories from directory-tree# Dependencies: https://github.com/xu-song/hexo-auto-category# depth: the max_depth of directory-tree you want to generate, should &gt; 0auto_category:\tenable: true\tdepth:3 除此之外最好修改一下 _config.yml 中的两处默认配置： 12345# 修改 permalink 让你的文章链接更加友好，并且有益于 SEOpermalink: :year/:month/:hash.html# 规定你的新文章在 _post 目录下是以 cateory new_post_name: :category/:title 在每个文章的开头添加以下： Obsidian可以创建模板 123456---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;categories: tags:--- 利用Git钩子函数触发更新 查看当前仓库中 Git 钩子脚本的路径 1git config core.hooksPath 如果是~/.githooks要改成~/.git/hooks 1git config core.hooksPath .git/hooks 在.git/hooks目录下新建一个pre-commit文件 可以先在该文件中写入echo hello world!，然后在git bash执行sh pre-commit或者./pre-commit测试钩子能不能正常执行 没问题后，将如下命令写到文件里: 12#!/bin/shhexo generate &amp;&amp; git add . 之所以后面追加git add .，是因为generate后，所有文章的Front-matter信息会更新，所以要将所有修改重新添加进来 注意第一行一定要加上#!/bin/sh，这个不是注释！ 可是使用git commit 试试是否成功 这样你新建一篇博客的工作流就简化为： 创建分类目录，写文章； 填写 title、date、tag 等元信息; 添加 git 工作区变更，并提交并推送代码到 github。 参考 Obsidian+Git完美维护Hexo博客 Hexo + Obsidian + Git 完美的博客部署与编辑方案","tags":[null,null],"categories":[null]},{"title":"Pyqt Designer","path":"/notes/杂谈/Pyqt Designer.html","content":"一些常用属性 minimumSize： 表示部件能被缩小到的最小尺寸，单位为像素，缩小到该尺寸后不能再进一步缩小了。如果部件在布局管理器中，且布局管理器也设置了最小尺寸，则部件本身的最小尺寸以部件的minimumSize为准，布局管理器设置的不起作用。 sizePolicy 部件的sizePolicy属性用于说明部件在布局管理中的缩放方式，当部件没有在布局管理器中时，该设置无效。 其中的常量值本身是由枚举类型PolicyFlag 的多个值组合而成，PolicyFlag 的取值及含义如下 contextMenuPolicy contextMenuPolicy为部件的快捷菜单策略，快捷菜单通过在部件上点击鼠标右键触发。","tags":[null],"categories":[null]},{"title":"安装docker","path":"/notes/杂谈/安装docker.html","content":"1. 安装docker 卸载旧版本 123sudo apt-get remove docker \\ docker-engine \\ docker.io 使用 APT 安装 由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 12345678sudo apt-get updatesudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 12345curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg# 官方源# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 然后，我们需要向 sources.list 中添加 Docker 软件源 123456789echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 官方源# echo \\# &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。 安装Docker 1sudo apt-get install docker-ce docker-ce-cli containerd.io 启动Docker 123sudo systemctl enable dockersudo systemctl start dockerdocker -v\t# 检查docker版本 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： 1sudo groupadd docker 将当前用户加入 docker 组： 1sudo usermod -aG docker $USER 退出当前终端并重新登录，进行如下测试。 测试docker是否安装成功 1docker run --rm hello-world 输出以下内容： 1234567891011121314151617181920212223242526Unable to find image &#x27;hello-world:latest&#x27; locallylatest: Pulling from library/hello-worldb8dfde127a29: Pull completeDigest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 2. 迁移docker的默认安装（存储）路径Docker版本（23.0.3）修改安装(存储)目录：通过修改(新建) &#x2F;etc&#x2F;docker&#x2F;daemon.json ，指定 data-root 参数的值。 按如下操作： 1sudo vim /etc/docker/daemon.json 修改文件： 1234&#123; &quot;data-root&quot;: &quot;/store/software/docker&quot;, &quot;storage-driver&quot;: &quot;overlay2&quot;&#125; 将data-root改成你要迁移的路径 3. Docker – GPU镜像 安装docker–nvidia 1234567# 1、添加源distribution=$(. /etc/os-release;echo $ID$VERSION_ID)sudo curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -sudo curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list# 2、安装并重启sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkitsudo systemctl restart docker 拉取docker镜像 从nvidia&#x2F;cuda选择合适的镜像 1docker pull nvidia/cuda:11.6.1-cudnn8-devel-ubuntu20.04 创建容器 1docker run --name test -idt --gpus all nvidia/cuda:11.6.1-cudnn8-devel-ubuntu20.04 也可以通过写”device&#x3D;0”或者’”device&#x3D;0,1,2,3”‘来指定GPU 进入容器 1docker exec -it test /bin/bash ​ 使用nvidia-smi查看GPU信息 4. 安装Conda 进入容器 1docker exec -it test /bin/bash 进行基础的网络安装 1234apt-get updateapt install net-tools # ifconfig apt install iputils-ping # pingapt-get install -y wget # wget 找anaconda安装包并下载 conda官网 1wget https://repo.anaconda.com/archive/Anaconda3-5.3.0-Linux-x86_64.sh 安装解压程序 1apt-get install bzip2 找到anaconda.sh并进行解压安装 12chmod +x Anaconda3-5.3.0-Linux-x86_64.sh./Anaconda3-5.3.0-Linux-x86_64.sh 回车，一直yes ,vscode可以不进行安装 进行环境变量配置 12export PATH=$PATH:/root/anaconda3/bin\t# 默认安装在root/anaconda3source ~/.bashrc 使用conda -V查看版本信息 123conda -V输出：conda 4.5.11 conda activate 和 conda deactivate 报错：CommandNotFoundError: Your shell has not been properly configured to use ‘conda activate’. 输入以下命令：： 12source activatesource deactivate 5. 将本地环境部署到docker在本地环境中将需要打包的代码复制到docker中： 123# 获取docker中conda安装地址conda info --env# 输出： /root/anaconda3 将本地环境复制到docker中（使用ctrl + d 退出） 1docker cp your_env_path test://root/anaconda3/envs 再使用docker cp命令将代码复制到容器内 保存所作的修改！ 1docker commit -a &#x27;author&#x27; -m &#x27;instruction&#x27; test image_test 该命令各字段： test ：容器名字 image_test：保存的镜像的名字。 打包镜像 1docker save -o test_tar.tar image_test test_tar.tar: 压缩包名称 ， image_test： 镜像名称 加载已经打包好的镜像 1docker load -i test_tar.tar 参考： Docker–从入门到实践 两种方法迁移 Docker 的默认安装(存储)目录 Ubuntu18.04安装docker及nvidia docker","tags":[null,null],"categories":[null]},{"title":"nonebot搭建QQ机器人","path":"/notes/杂谈/nonebot搭建QQ机器人.html","content":"框架介绍NoneBot2 是一个现代、跨平台、可扩展的 Python 聊天机器人框架，它基于 Python 的类型注解和异步特性，能够为你的需求实现提供便捷灵活的支持。 nonebot官方文档 搭建步骤 请确保你的 Python 版本 &gt;&#x3D; 3.8 1. 通过脚手架安装nb 安装 pipx 12python -m pip install --user pipxpython -m pipx ensurepath 安装脚手架 1pipx install nb-cli 如果提醒以下内容： 1234567 installed package nb-cli 1.0.5, installed using Python 3.10.9 These apps are now globally available - nb.exe⚠️ Note: &#x27;C:\\\\Users\\\\WMGray\\\\.local\\\\bin&#x27; is not on your PATH environment variable. These apps will not be globally accessible until your PATH is updated. Run `pipx ensurepath` to automatically add it, or manually modify your PATH in your shell&#x27;s config file (i.e. ~/.bashrc).done! ✨ 🌟 ✨ 请按照上面的警告输入命令：Run pipx ensurepath to automatically add it, or manually modify your PATH in your shell’s config file 然后根据接下来的输出进行 2.创建nb项目 输入nb来进行交互 选择创建一个NoneBot项目 选择模板 输入项目名称 选择适配器–FastAPI 选择驱动器–OneBotV11 3.项目配置 在.env更改配置项 123456HOST=127.0.0.1 # 配置 NoneBot2 监听的 IP/主机名PORT=8080 # 配置 NoneBot2 监听的端口SUPERUSERS=[&quot;123456789&quot;, &quot;987654321&quot;] # 配置 NoneBot 超级用户NICKNAME=[&quot;awesome&quot;, &quot;bot&quot;] # 配置机器人的昵称COMMAND_START=[&quot;/&quot;, &quot;&quot;] # 配置命令起始字符COMMAND_SEP=[&quot;.&quot;] # 配置命令分割字符 其他参数见NoneBot配置 4.下载gocq go-cqhttp选择合适的版本 双击exe生成运行脚本 选择通信方式（本文选择的反向WebSocket） 若要支持任意格式语音发送，可安装ffmpeg 从 这里 下载 并解压, 并为 bin 这个文件夹添加环境变量 然后在 cmd 输入 (不能使用 powershell） 12setx /M PATH &quot;C:\\Program Files\\ffmpeg\\bin;%PATH%&quot;# 自行将这个指令中的 C:\\Program Files 替换成你的解压目录 生成config.yaml后修改以下信息 1234uin: 1233456 # QQ账号password: &#x27;&#x27; # 密码为空时使用扫码登录.... universal: ws://127.0.0.1:端口号/onebot/v11/ws/\t#端口号同bot项目下的.env端口 5. 启动bot1nb run\t# 在项目界面 同时，运行go-cqhttp.bat","tags":[null,null,null],"categories":[null]},{"title":"linux创建用户并赋予sudo权限","path":"/notes/杂谈/linux/linux创建用户并赋予sudo权限.html","content":"https://www.sunzhongwei.com/ubuntu-2004-to-add-a-new-user-and-give-sudo-permissions 地址 36.153.240.230 端口 30200 账号 wq 密码 wq123456","tags":[null],"categories":[null,null]}]